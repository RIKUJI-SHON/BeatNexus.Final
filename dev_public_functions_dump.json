[
  {
    "schema_name": "public",
    "function_name": "admin_force_release_email",
    "return_type": "json",
    "arguments": "p_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.admin_force_release_email(p_email text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_user_count INTEGER;\n  v_timestamp BIGINT;\nBEGIN\n  -- æŒ‡å®šã•ã‚ŒãŸãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°ã‚’ç¢ºèª\n  SELECT COUNT(*) INTO v_user_count\n  FROM auth.users \n  WHERE email = p_email;\n  \n  IF v_user_count = 0 THEN\n    RETURN json_build_object(\n      'success', true,\n      'message', 'Email address is already available',\n      'email', p_email\n    );\n  END IF;\n  \n  v_timestamp := EXTRACT(EPOCH FROM NOW())::BIGINT;\n  \n  -- è©²å½“ã™ã‚‹auth.usersãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å®Œå…¨ã«åŒ¿ååŒ–\n  UPDATE auth.users\n  SET \n    email = 'force-released-' || v_timestamp || '-' || SUBSTRING(id::text, 1, 8) || '@admin.released',\n    raw_user_meta_data = jsonb_build_object(\n      'admin_force_released', true,\n      'release_timestamp', v_timestamp,\n      'original_email_force_released', p_email,\n      'release_method', 'admin_force_release'\n    ),\n    updated_at = NOW()\n  WHERE email = p_email;\n  \n  RETURN json_build_object(\n    'success', true,\n    'message', 'Email address forcefully released',\n    'email', p_email,\n    'affected_users', v_user_count,\n    'timestamp', v_timestamp\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "admin_force_release_email_v2",
    "return_type": "json",
    "arguments": "p_email text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.admin_force_release_email_v2(p_email text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_user_count INTEGER;\n  v_identity_count INTEGER;\n  v_timestamp BIGINT;\nBEGIN\n  -- æŒ‡å®šã•ã‚ŒãŸãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°ã‚’ç¢ºèª\n  SELECT COUNT(*) INTO v_user_count\n  FROM auth.users \n  WHERE email = p_email;\n  \n  -- identitiesãƒ†ãƒ¼ãƒ–ãƒ«ã®è©²å½“ãƒ‡ãƒ¼ã‚¿æ•°ã‚‚ç¢ºèª\n  SELECT COUNT(*) INTO v_identity_count\n  FROM auth.identities \n  WHERE provider_id = p_email \n     OR identity_data::text LIKE '%' || p_email || '%';\n  \n  IF v_user_count = 0 AND v_identity_count = 0 THEN\n    RETURN json_build_object(\n      'success', true,\n      'message', 'Email address is already completely available',\n      'email', p_email\n    );\n  END IF;\n  \n  v_timestamp := EXTRACT(EPOCH FROM NOW())::BIGINT;\n  \n  -- è©²å½“ã™ã‚‹auth.usersãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’å®Œå…¨ã«åŒ¿ååŒ–\n  UPDATE auth.users\n  SET \n    email = 'force-released-' || v_timestamp || '-' || SUBSTRING(id::text, 1, 8) || '@admin.released',\n    raw_user_meta_data = jsonb_build_object(\n      'admin_force_released', true,\n      'release_timestamp', v_timestamp,\n      'original_email_force_released', p_email,\n      'release_method', 'admin_force_release_v2'\n    ),\n    updated_at = NOW()\n  WHERE email = p_email;\n  \n  -- ğŸ†• auth.identitiesã‹ã‚‰ã‚‚å®Œå…¨å‰Šé™¤\n  DELETE FROM auth.identities \n  WHERE provider_id = p_email \n     OR identity_data::text LIKE '%' || p_email || '%';\n  \n  RETURN json_build_object(\n    'success', true,\n    'message', 'Email address forcefully released (including identities)',\n    'email', p_email,\n    'affected_users', v_user_count,\n    'affected_identities', v_identity_count,\n    'timestamp', v_timestamp\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "auto_release_deleted_emails",
    "return_type": "json",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.auto_release_deleted_emails()\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_updated_count INTEGER := 0;\n  v_user_record RECORD;\n  v_timestamp BIGINT;\n  v_new_email TEXT;\nBEGIN\n  -- deleted@example.com å½¢å¼ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ä¸€æ„ãªå½¢å¼ã«å¤‰æ›\n  FOR v_user_record IN\n    SELECT id, email \n    FROM auth.users \n    WHERE email = 'deleted@example.com'\n      AND (raw_user_meta_data->>'email_immediately_released')::boolean IS NOT TRUE\n    LIMIT 100  -- ä¸€åº¦ã«å‡¦ç†ã™ã‚‹ä»¶æ•°ã‚’åˆ¶é™\n  LOOP\n    -- ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ãã®æ–°ã—ã„ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ç”Ÿæˆ\n    v_timestamp := EXTRACT(EPOCH FROM NOW())::BIGINT;\n    v_new_email := 'deleted-' || SUBSTRING(v_user_record.id::text, 1, 8) || '-' || v_timestamp || '@deleted.local';\n    \n    -- auth.users ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ›´æ–°\n    UPDATE auth.users\n    SET \n      email = v_new_email,\n      raw_user_meta_data = COALESCE(raw_user_meta_data, '{}'::jsonb) || \n        jsonb_build_object(\n          'email_auto_released_at', NOW()::text,\n          'email_immediately_released', true,\n          'auto_release_timestamp', v_timestamp,\n          'previous_email', v_user_record.email\n        ),\n      updated_at = NOW()\n    WHERE id = v_user_record.id;\n    \n    -- profilesãƒ†ãƒ¼ãƒ–ãƒ«ã‚‚æ›´æ–°\n    UPDATE profiles\n    SET \n      email = v_new_email,\n      updated_at = NOW()\n    WHERE id = v_user_record.id;\n    \n    v_updated_count := v_updated_count + 1;\n  END LOOP;\n  \n  RETURN json_build_object(\n    'success', true,\n    'updated_count', v_updated_count,\n    'message', 'Email addresses auto-released for reuse'\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "auto_set_user_language",
    "return_type": "trigger",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.auto_set_user_language()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- æ–°è¦ä½œæˆæ™‚ã«languageãŒNULLã®å ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§è‹±èªã‚’è¨­å®š\n  IF NEW.language IS NULL THEN\n    NEW.language := 'en';\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "calculate_elo_rating",
    "return_type": "json",
    "arguments": "winner_rating integer, loser_rating integer, k_factor integer DEFAULT 32",
    "function_definition": "CREATE OR REPLACE FUNCTION public.calculate_elo_rating(winner_rating integer, loser_rating integer, k_factor integer DEFAULT 32)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  expected_winner NUMERIC;\n  expected_loser NUMERIC;\n  new_winner_rating INTEGER;\n  new_loser_rating INTEGER;\nBEGIN\n  -- Calculate expected scores (probability of winning)\n  expected_winner := 1.0 / (1.0 + power(10.0, (loser_rating - winner_rating) / 400.0));\n  expected_loser := 1.0 / (1.0 + power(10.0, (winner_rating - loser_rating) / 400.0));\n  \n  -- Calculate new ratings\n  new_winner_rating := winner_rating + k_factor * (1.0 - expected_winner);\n  new_loser_rating := loser_rating + k_factor * (0.0 - expected_loser);\n  \n  -- Ensure ratings don't go below minimum (1100) - Updated from 800\n  new_winner_rating := GREATEST(new_winner_rating, 1100);\n  new_loser_rating := GREATEST(new_loser_rating, 1100);\n  \n  RETURN json_build_object(\n    'winner_rating', new_winner_rating,\n    'loser_rating', new_loser_rating,\n    'rating_change_winner', new_winner_rating - winner_rating,\n    'rating_change_loser', new_loser_rating - loser_rating\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "calculate_elo_rating_change",
    "return_type": "integer",
    "arguments": "player_rating integer, opponent_rating integer, result numeric, k_factor integer DEFAULT 32",
    "function_definition": "CREATE OR REPLACE FUNCTION public.calculate_elo_rating_change(player_rating integer, opponent_rating integer, result numeric, k_factor integer DEFAULT 32)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  expected_score NUMERIC;\n  rating_change INTEGER;\nBEGIN\n  -- æœŸå¾…å‹ç‡ã‚’è¨ˆç®— (Elo Rating System)\n  expected_score := 1.0 / (1.0 + POWER(10.0, (opponent_rating - player_rating) / 400.0));\n  \n  -- ãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°å¤‰å‹•ã‚’è¨ˆç®—\n  rating_change := ROUND(k_factor * (result - expected_score));\n  \n  RETURN rating_change;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "calculate_elo_rating_with_format",
    "return_type": "json",
    "arguments": "winner_rating integer, loser_rating integer, battle_format text DEFAULT 'MAIN_BATTLE'::text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.calculate_elo_rating_with_format(winner_rating integer, loser_rating integer, battle_format text DEFAULT 'MAIN_BATTLE'::text)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  k_factor INTEGER;\n  expected_winner NUMERIC;\n  expected_loser NUMERIC;\n  new_winner_rating INTEGER;\n  new_loser_rating INTEGER;\nBEGIN\n  -- Get K-factor based on battle format\n  k_factor := get_k_factor_by_format(battle_format);\n  \n  -- Calculate expected scores (probability of winning)\n  expected_winner := 1.0 / (1.0 + power(10.0, (loser_rating - winner_rating) / 400.0));\n  expected_loser := 1.0 / (1.0 + power(10.0, (winner_rating - loser_rating) / 400.0));\n  \n  -- Calculate new ratings\n  new_winner_rating := winner_rating + k_factor * (1.0 - expected_winner);\n  new_loser_rating := loser_rating + k_factor * (0.0 - expected_loser);\n  \n  -- Ensure ratings don't go below minimum (1100)\n  new_winner_rating := GREATEST(new_winner_rating, 1100);\n  new_loser_rating := GREATEST(new_loser_rating, 1100);\n  \n  RETURN json_build_object(\n    'winner_rating', new_winner_rating,\n    'loser_rating', new_loser_rating,\n    'rating_change_winner', new_winner_rating - winner_rating,\n    'rating_change_loser', new_loser_rating - loser_rating,\n    'k_factor_used', k_factor,\n    'battle_format', battle_format\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "calculate_tie_rating_with_format",
    "return_type": "json",
    "arguments": "player1_rating integer, player2_rating integer, battle_format text",
    "function_definition": "CREATE OR REPLACE FUNCTION public.calculate_tie_rating_with_format(player1_rating integer, player2_rating integer, battle_format text)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  k_factor INTEGER;\n  player1_change INTEGER;\n  player2_change INTEGER;\n  new_player1_rating INTEGER;\n  new_player2_rating INTEGER;\nBEGIN\n  -- Get K-factor based on battle format\n  k_factor := get_k_factor_by_format(battle_format);\n  \n  -- Calculate rating changes for tie (result = 0.5 for both players)\n  player1_change := calculate_elo_rating_change(player1_rating, player2_rating, 0.5, k_factor);\n  player2_change := calculate_elo_rating_change(player2_rating, player1_rating, 0.5, k_factor);\n  \n  -- Apply changes with minimum rating protection\n  new_player1_rating := GREATEST(player1_rating + player1_change, 1100);\n  new_player2_rating := GREATEST(player2_rating + player2_change, 1100);\n  \n  RETURN json_build_object(\n    'player1_rating', new_player1_rating,\n    'player2_rating', new_player2_rating,\n    'player1_change', new_player1_rating - player1_rating,\n    'player2_change', new_player2_rating - player2_rating,\n    'k_factor_used', k_factor,\n    'battle_format', battle_format\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "call_edge_function",
    "return_type": "void",
    "arguments": "function_name text, payload jsonb",
    "function_definition": "CREATE OR REPLACE FUNCTION public.call_edge_function(function_name text, payload jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  edge_function_url text;\nBEGIN\n  -- Edge Function ã®URL ã‚’æ§‹ç¯‰\n  edge_function_url := 'https://wdttluticnlqzmqmfvgt.supabase.co/functions/v1/' || function_name;\n\n  -- HTTP POST ã§Edge Functionã‚’å‘¼ã³å‡ºã—ï¼ˆéåŒæœŸï¼‰\n  -- NOTE: http æ‹¡å¼µã‚’ä½¿ç”¨\n  PERFORM net.http_post(\n    url := edge_function_url,\n    body := payload,\n    headers := jsonb_build_object(\n      'Content-Type', 'application/json',\n      'Authorization', 'Bearer ' || current_setting('request.jwt.claims', true)::jsonb->>'aud'\n    )\n  );\n  \nEXCEPTION WHEN OTHERS THEN\n  -- ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦ã‚‚ãƒˆãƒªã‚¬ãƒ¼å‡¦ç†ã¯ç¶™ç¶š\n  RAISE LOG 'Failed to call edge function %: %', function_name, SQLERRM;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "can_submit_video",
    "return_type": "boolean",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.can_submit_video()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_active_season RECORD;\n  v_season_end_date TIMESTAMPTZ;\nBEGIN\n  -- ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚·ãƒ¼ã‚ºãƒ³ã‚’å–å¾—\n  SELECT * INTO v_active_season\n  FROM public.seasons\n  WHERE status = 'active'\n    AND start_at <= NOW()\n    AND end_at >= NOW()\n  ORDER BY start_at DESC\n  LIMIT 1;\n  \n  -- ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚·ãƒ¼ã‚ºãƒ³ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯æŠ•ç¨¿ä¸å¯\n  IF NOT FOUND THEN\n    RETURN FALSE;\n  END IF;\n  \n  -- ã‚·ãƒ¼ã‚ºãƒ³çµ‚äº†æ—¥ã‹ã‚‰5æ—¥ä»¥å†…ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯\n  v_season_end_date := v_active_season.end_at;\n  \n  -- ç¾åœ¨æ™‚åˆ»ãŒã‚·ãƒ¼ã‚ºãƒ³çµ‚äº†5æ—¥å‰ä»¥é™ã®å ´åˆã¯æŠ•ç¨¿ä¸å¯\n  IF NOW() >= (v_season_end_date - INTERVAL '5 days') THEN\n    RETURN FALSE;\n  END IF;\n  \n  -- ä¸Šè¨˜æ¡ä»¶ã‚’æº€ãŸã•ãªã„å ´åˆã¯æŠ•ç¨¿å¯èƒ½\n  RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "cancel_vote",
    "return_type": "json",
    "arguments": "p_battle_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.cancel_vote(p_battle_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_user_id UUID;\n  v_existing_vote CHAR(1);\n  v_existing_season_id UUID;\n  v_existing_comment TEXT;\n  v_has_comment BOOLEAN := FALSE;\n  v_vote_points_decrement INTEGER := 0;\n  v_vote_count_decrement INTEGER := 0;  -- ğŸ†• é€šç®—æŠ•ç¥¨ã‚«ã‚¦ãƒ³ãƒˆæ¸›ç®—ç”¨ã®å¤‰æ•°\n  v_current_season_id UUID;\n  v_debug_info JSON;\nBEGIN\n  v_user_id := auth.uid();\n  \n  IF v_user_id IS NULL THEN\n    RETURN json_build_object('success', false, 'error', 'Not authenticated');\n  END IF;\n\n  -- æ—¢å­˜ã®æŠ•ç¥¨æƒ…å ±ã‚’å–å¾—ï¼ˆã‚³ãƒ¡ãƒ³ãƒˆã®æœ‰ç„¡ã‚‚ç¢ºèªï¼‰\n  SELECT vote, season_id, comment \n  INTO v_existing_vote, v_existing_season_id, v_existing_comment\n  FROM battle_votes\n  WHERE battle_id = p_battle_id AND user_id = v_user_id;\n\n  IF v_existing_vote IS NULL THEN\n    RETURN json_build_object('success', false, 'error', 'No vote to cancel');\n  END IF;\n\n  -- ã‚³ãƒ¡ãƒ³ãƒˆã®æœ‰ç„¡ã‚’åˆ¤å®š\n  v_has_comment := v_existing_comment IS NOT NULL AND LENGTH(TRIM(v_existing_comment)) > 0;\n\n  -- ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ã‚ºãƒ³ã‚’å–å¾—\n  BEGIN\n    SELECT id INTO v_current_season_id \n    FROM public.seasons \n    WHERE status = 'active'\n      AND start_at <= NOW()\n      AND end_at >= NOW()\n    ORDER BY start_at DESC\n    LIMIT 1;\n  EXCEPTION WHEN OTHERS THEN\n    v_current_season_id := NULL;\n  END;\n\n  -- ãƒã‚¤ãƒ³ãƒˆæ¸›ç®—é‡ã‚’æ±ºå®š\n  IF v_existing_season_id IS NOT NULL THEN\n    IF v_has_comment THEN\n      -- ğŸ”§ ä¿®æ­£: ã‚³ãƒ¡ãƒ³ãƒˆä»˜ãæŠ•ç¥¨ã®å–ã‚Šæ¶ˆã—: ã‚·ãƒ¼ã‚ºãƒ³ãƒã‚¤ãƒ³ãƒˆ-3ã€é€šç®—æŠ•ç¥¨ã‚«ã‚¦ãƒ³ãƒˆ-3\n      v_vote_points_decrement := 3;\n      v_vote_count_decrement := 3;\n    ELSE\n      -- æ™®é€šã®æŠ•ç¥¨ã®å–ã‚Šæ¶ˆã—: ã‚·ãƒ¼ã‚ºãƒ³ãƒã‚¤ãƒ³ãƒˆ-1ã€é€šç®—æŠ•ç¥¨ã‚«ã‚¦ãƒ³ãƒˆ-1\n      v_vote_points_decrement := 1;\n      v_vote_count_decrement := 1;\n    END IF;\n  ELSE\n    -- ã‚·ãƒ¼ã‚ºãƒ³IDãŒãªã„å ´åˆã¯ã‚·ãƒ¼ã‚ºãƒ³ãƒã‚¤ãƒ³ãƒˆæ¸›ç®—ãªã—ã€é€šç®—æŠ•ç¥¨ã‚«ã‚¦ãƒ³ãƒˆã®ã¿-1\n    v_vote_points_decrement := 0;\n    v_vote_count_decrement := 1;\n  END IF;\n\n  -- ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ä½œæˆ\n  v_debug_info := json_build_object(\n    'has_comment', v_has_comment,\n    'comment_length', COALESCE(LENGTH(v_existing_comment), 0),\n    'vote_points_decrement', v_vote_points_decrement,\n    'vote_count_decrement', v_vote_count_decrement,  -- ğŸ†• é€šç®—æŠ•ç¥¨ã‚«ã‚¦ãƒ³ãƒˆæ¸›ç®—é‡\n    'existing_season_id', v_existing_season_id,\n    'current_season_id', v_current_season_id,\n    'vote_type', CASE WHEN v_has_comment THEN 'comment_vote' ELSE 'simple_vote' END,\n    'current_time', NOW()\n  );\n\n  -- æŠ•ç¥¨ã‚’å‰Šé™¤\n  DELETE FROM battle_votes\n  WHERE battle_id = p_battle_id AND user_id = v_user_id;\n\n  -- ãƒãƒˆãƒ«ã®æŠ•ç¥¨æ•°ã‚’æ›´æ–°\n  IF v_existing_vote = 'A' THEN\n    UPDATE active_battles SET votes_a = votes_a - 1 WHERE id = p_battle_id;\n  ELSE\n    UPDATE active_battles SET votes_b = votes_b - 1 WHERE id = p_battle_id;\n  END IF;\n\n  -- ğŸ”§ ä¿®æ­£: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æŠ•ç¥¨æ•°ã‚’æ›´æ–°ï¼ˆã‚³ãƒ¡ãƒ³ãƒˆæœ‰ç„¡ã«å¿œã˜ãŸé©åˆ‡ãªãƒã‚¤ãƒ³ãƒˆæ¸›ç®—ï¼‰\n  IF v_existing_season_id IS NOT NULL THEN\n    UPDATE profiles \n    SET \n      vote_count = GREATEST(0, vote_count - v_vote_count_decrement),  -- ğŸ”§ ä¿®æ­£: ã‚³ãƒ¡ãƒ³ãƒˆæœ‰ç„¡ã«å¿œã˜ãŸæ¸›ç®—\n      season_vote_points = GREATEST(0, season_vote_points - v_vote_points_decrement),\n      updated_at = NOW()\n    WHERE id = v_user_id;\n  ELSE\n    -- ã‚·ãƒ¼ã‚ºãƒ³IDãŒãªã„å ´åˆã¯é€šç®—æŠ•ç¥¨æ•°ã®ã¿æ¸›ç®—\n    UPDATE profiles \n    SET \n      vote_count = GREATEST(0, vote_count - v_vote_count_decrement),  -- ğŸ”§ ä¿®æ­£: ã‚³ãƒ¡ãƒ³ãƒˆæœ‰ç„¡ã«å¿œã˜ãŸæ¸›ç®—\n      updated_at = NOW()\n    WHERE id = v_user_id;\n  END IF;\n\n  RETURN json_build_object(\n    'success', true, \n    'cancelled_vote', v_existing_vote,\n    'had_comment', v_has_comment,\n    'comment_preview', CASE \n      WHEN v_has_comment THEN LEFT(v_existing_comment, 50) || '...'\n      ELSE NULL \n    END,\n    'vote_points_deducted', v_vote_points_decrement,\n    'vote_count_deducted', v_vote_count_decrement,  -- ğŸ†• é€šç®—æŠ•ç¥¨ã‚«ã‚¦ãƒ³ãƒˆæ¸›ç®—é‡\n    'had_season_id', v_existing_season_id IS NOT NULL,\n    'season_id', v_existing_season_id,\n    'vote_type', CASE WHEN v_has_comment THEN 'comment_vote' ELSE 'simple_vote' END,\n    'debug', v_debug_info\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "check_submission_cooldown",
    "return_type": "json",
    "arguments": "p_user_id uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_submission_cooldown(p_user_id uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_last_submission_time TIMESTAMPTZ;\n  v_hours_since_last NUMERIC;\n  v_cooldown_remaining_minutes INTEGER;\n  v_can_submit BOOLEAN;\n  v_message_key TEXT;\n  v_message_params JSON;\nBEGIN\n  -- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœ€æ–°ã®æŠ•ç¨¿æ™‚åˆ»ã‚’å–å¾—\n  SELECT created_at INTO v_last_submission_time\n  FROM submissions\n  WHERE user_id = p_user_id\n  ORDER BY created_at DESC\n  LIMIT 1;\n\n  -- æœ€åˆã®æŠ•ç¨¿ã®å ´åˆã¯æŠ•ç¨¿å¯èƒ½\n  IF v_last_submission_time IS NULL THEN\n    RETURN json_build_object(\n      'can_submit', true,\n      'last_submission_time', null,\n      'hours_since_last', null,\n      'cooldown_remaining_minutes', 0,\n      'message_key', 'submission.cooldown.canSubmit',\n      'message_params', json_build_object()\n    );\n  END IF;\n\n  -- æœ€å¾Œã®æŠ•ç¨¿ã‹ã‚‰ã®çµŒéæ™‚é–“ã‚’è¨ˆç®—\n  v_hours_since_last := EXTRACT(EPOCH FROM (NOW() - v_last_submission_time)) / 3600;\n  \n  -- 1æ™‚é–“ï¼ˆ60åˆ†ï¼‰çµŒéã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯\n  IF v_hours_since_last >= 1 THEN\n    v_can_submit := true;\n    v_cooldown_remaining_minutes := 0;\n    v_message_key := 'submission.cooldown.canSubmit';\n    v_message_params := json_build_object();\n  ELSE\n    v_can_submit := false;\n    v_cooldown_remaining_minutes := CEIL((1 - v_hours_since_last) * 60);\n    v_message_key := 'submission.cooldown.restriction';\n    v_message_params := json_build_object(\n      'hours', FLOOR(v_cooldown_remaining_minutes / 60),\n      'minutes', v_cooldown_remaining_minutes % 60,\n      'totalMinutes', v_cooldown_remaining_minutes\n    );\n  END IF;\n\n  RETURN json_build_object(\n    'can_submit', v_can_submit,\n    'last_submission_time', v_last_submission_time,\n    'hours_since_last', ROUND(v_hours_since_last, 2),\n    'cooldown_remaining_minutes', v_cooldown_remaining_minutes,\n    'message_key', v_message_key,\n    'message_params', v_message_params\n  );\n\nEXCEPTION\n  WHEN OTHERS THEN\n    RETURN json_build_object(\n      'can_submit', false,\n      'last_submission_time', null,\n      'hours_since_last', null,\n      'cooldown_remaining_minutes', 0,\n      'message_key', 'submission.cooldown.error',\n      'message_params', json_build_object('error', SQLERRM)\n    );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "cleanup_all_deleted_user_videos",
    "return_type": "json",
    "arguments": "",
    "function_definition": "CREATE OR REPLACE FUNCTION public.cleanup_all_deleted_user_videos()\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_deleted_user RECORD;\n  v_cleanup_result JSON;\n  v_total_videos_deleted INTEGER := 0;\n  v_total_videos_failed INTEGER := 0;\n  v_processed_users INTEGER := 0;\nBEGIN\n  -- å‰Šé™¤æ¸ˆã¿ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒ«ãƒ¼ãƒ—å‡¦ç†\n  FOR v_deleted_user IN\n    SELECT id \n    FROM profiles \n    WHERE is_deleted = TRUE\n    LIMIT 50  -- ä¸€åº¦ã«å‡¦ç†ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°ã‚’åˆ¶é™\n  LOOP\n    -- å„ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å‹•ç”»ã‚’å‰Šé™¤\n    SELECT cleanup_all_deleted_user_videos() INTO v_cleanup_result;\n    \n    -- çµæœã‚’é›†è¨ˆ\n    v_total_videos_deleted := v_total_videos_deleted + COALESCE((v_cleanup_result->>'deleted_count')::INTEGER, 0);\n    v_total_videos_failed := v_total_videos_failed + COALESCE((v_cleanup_result->>'failed_count')::INTEGER, 0);\n    v_processed_users := v_processed_users + 1;\n    \n  END LOOP;\n  \n  RETURN json_build_object(\n    'success', true,\n    'processed_users', v_processed_users,\n    'total_videos_deleted', v_total_videos_deleted,\n    'total_videos_failed', v_total_videos_failed,\n    'message', 'Bulk video cleanup completed'\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "complete_battle_with_season_update",
    "return_type": "json",
    "arguments": "p_battle_id uuid, p_winner_id uuid DEFAULT NULL::uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.complete_battle_with_season_update(p_battle_id uuid, p_winner_id uuid DEFAULT NULL::uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$DECLARE\n  v_global_rating_result JSON;\n  v_season_points_result JSON;\n  v_current_season_id UUID;\nBEGIN\n  -- ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚·ãƒ¼ã‚ºãƒ³ã‚’å–å¾—\n  SELECT id INTO v_current_season_id \n  FROM seasons \n  WHERE status = 'active'\n  ORDER BY created_at DESC\n  LIMIT 1;\n\n  -- 1. æ—¢å­˜ã®global_ratingæ›´æ–°ï¼ˆæ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ï¼‰\n  BEGIN\n    SELECT update_battle_ratings_safe(p_battle_id, p_winner_id) INTO v_global_rating_result;\n  EXCEPTION WHEN OTHERS THEN\n    v_global_rating_result := json_build_object(\n      'success', false,\n      'error', 'global_rating_update_failed',\n      'message', SQLERRM\n    );\n  END;\n\n  -- 2. æ–°ã—ã„season_pointsæ›´æ–°ï¼ˆã‚·ãƒ¼ã‚ºãƒ³åˆ¶ï¼‰\n  BEGIN\n    IF v_current_season_id IS NOT NULL THEN\n      SELECT update_season_points_after_battle(p_battle_id, p_winner_id) INTO v_season_points_result;\n    ELSE\n      v_season_points_result := json_build_object(\n        'success', false,\n        'error', 'no_active_season',\n        'message', 'ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚·ãƒ¼ã‚ºãƒ³ãŒãªã„ãŸã‚ã‚·ãƒ¼ã‚ºãƒ³ãƒã‚¤ãƒ³ãƒˆæ›´æ–°ã‚’ã‚¹ã‚­ãƒƒãƒ—'\n      );\n    END IF;\n  EXCEPTION WHEN OTHERS THEN\n    v_season_points_result := json_build_object(\n      'success', false,\n      'error', 'season_points_update_failed',\n      'message', SQLERRM\n    );\n  END;\n\n  RETURN json_build_object(\n    'success', true,\n    'battle_id', p_battle_id,\n    'winner_id', p_winner_id,\n    'current_season_id', v_current_season_id,\n    'global_rating_update', v_global_rating_result,\n    'season_points_update', v_season_points_result\n  );\nEND;$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "complete_battle_with_video_archiving",
    "return_type": "json",
    "arguments": "p_battle_id uuid, p_winner_id uuid DEFAULT NULL::uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION public.complete_battle_with_video_archiving(p_battle_id uuid, p_winner_id uuid DEFAULT NULL::uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_battle_rec active_battles;\n  v_archived_battle_id UUID;\n  v_player1_video_url TEXT;  \n  v_player2_video_url TEXT;\n  v_player1_deleted BOOLEAN := FALSE;\n  v_player2_deleted BOOLEAN := FALSE;\n  v_rating_result JSON;\n  v_season_result JSON;\n  v_player1_username TEXT;\n  v_player2_username TEXT;\nBEGIN\n  -- 1. ãƒãƒˆãƒ«è©³ç´°ã‚’å–å¾—\n  SELECT * INTO v_battle_rec\n  FROM public.active_battles\n  WHERE id = p_battle_id;\n\n  IF NOT FOUND THEN\n    RETURN json_build_object(\n      'success', false,\n      'error', 'Battle not found'\n    );\n  END IF;\n\n  -- 2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‰Šé™¤çŠ¶æ…‹ã‚’ç¢ºèª\n  SELECT COALESCE(is_deleted, FALSE) INTO v_player1_deleted\n  FROM public.profiles \n  WHERE id = v_battle_rec.player1_user_id;\n\n  SELECT COALESCE(is_deleted, FALSE) INTO v_player2_deleted\n  FROM public.profiles \n  WHERE id = v_battle_rec.player2_user_id;\n\n  -- 3. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’å–å¾—ï¼ˆé€šçŸ¥ç”¨ï¼‰\n  SELECT username INTO v_player1_username\n  FROM public.profiles \n  WHERE id = v_battle_rec.player1_user_id;\n\n  SELECT username INTO v_player2_username\n  FROM public.profiles \n  WHERE id = v_battle_rec.player2_user_id;\n\n  -- 4. å‹•ç”»URLã‚’å–å¾—ï¼ˆæ°¸ç¶šä¿å­˜ç”¨ï¼‰\n  SELECT video_url INTO v_player1_video_url\n  FROM public.submissions\n  WHERE id = v_battle_rec.player1_submission_id;\n\n  SELECT video_url INTO v_player2_video_url\n  FROM public.submissions\n  WHERE id = v_battle_rec.player2_submission_id;\n\n  -- 5. archived_battlesãƒ†ãƒ¼ãƒ–ãƒ«ã«æŒ¿å…¥\n  INSERT INTO public.archived_battles (\n    original_battle_id,\n    winner_id,\n    final_votes_a,\n    final_votes_b,\n    battle_format,\n    player1_user_id,\n    player2_user_id,\n    player1_submission_id,\n    player2_submission_id,\n    player1_video_url,\n    player2_video_url,\n    archived_at,\n    created_at,\n    updated_at\n  ) VALUES (\n    p_battle_id,\n    p_winner_id,\n    v_battle_rec.votes_a,\n    v_battle_rec.votes_b,\n    v_battle_rec.battle_format,\n    v_battle_rec.player1_user_id,\n    v_battle_rec.player2_user_id,\n    v_battle_rec.player1_submission_id,\n    v_battle_rec.player2_submission_id,\n    v_player1_video_url,\n    v_player2_video_url,\n    NOW(),\n    NOW(),\n    NOW()\n  ) RETURNING id INTO v_archived_battle_id;\n\n  -- 6. archived_battle_votes ã«æŠ•ç¥¨ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼\n  INSERT INTO public.archived_battle_votes (\n    archived_battle_id,\n    user_id,\n    vote,\n    comment,\n    created_at\n  )\n  SELECT \n    v_archived_battle_id,\n    bv.user_id,\n    bv.vote,\n    bv.comment,\n    bv.created_at\n  FROM public.battle_votes bv\n  WHERE bv.battle_id = p_battle_id \n    AND bv.comment IS NOT NULL \n    AND bv.comment != '';\n\n  -- 7. submissionsãƒ†ãƒ¼ãƒ–ãƒ«ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°\n  UPDATE public.submissions\n  SET \n    status = 'BATTLE_ENDED',\n    updated_at = NOW()\n  WHERE id IN (v_battle_rec.player1_submission_id, v_battle_rec.player2_submission_id);\n\n  -- 8. ãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°æ›´æ–°ï¼ˆæ­£ã—ã„é–¢æ•°åã¨å¼•æ•°ã‚’ä½¿ç”¨ï¼‰\n  SELECT update_battle_ratings_safe(\n    p_battle_id,\n    p_winner_id,\n    v_player1_deleted,\n    v_player2_deleted\n  ) INTO v_rating_result;\n\n  -- 9. ã‚·ãƒ¼ã‚ºãƒ³ãƒã‚¤ãƒ³ãƒˆæ›´æ–°ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿ï¼‰\n  BEGIN\n    SELECT update_season_points_after_battle(\n      p_battle_id,\n      p_winner_id\n    ) INTO v_season_result;\n  EXCEPTION\n    WHEN undefined_function THEN\n      v_season_result := json_build_object('skipped', true, 'reason', 'function not found');\n  END;\n\n  -- ğŸ†• 10. ãƒãƒˆãƒ«çµæœé€šçŸ¥ã‚’é€ä¿¡\n  -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1ã¸ã®é€šçŸ¥\n  IF NOT v_player1_deleted THEN\n    IF p_winner_id = v_battle_rec.player1_user_id THEN\n      -- å‹åˆ©é€šçŸ¥\n      INSERT INTO public.notifications (\n        user_id,\n        title,\n        message,\n        type,\n        related_battle_id,\n        is_read,\n        created_at,\n        updated_at\n      ) VALUES (\n        v_battle_rec.player1_user_id,\n        'ãƒãƒˆãƒ«å‹åˆ©ï¼',\n        FORMAT('å¯¾æˆ¦ç›¸æ‰‹ %s ã•ã‚“ã¨ã®ãƒãƒˆãƒ«ã«å‹åˆ©ã—ã¾ã—ãŸï¼', COALESCE(v_player2_username, 'Unknown')),\n        'battle_win',\n        p_battle_id,\n        false,\n        NOW(),\n        NOW()\n      );\n    ELSIF p_winner_id = v_battle_rec.player2_user_id THEN\n      -- æ•—åŒ—é€šçŸ¥\n      INSERT INTO public.notifications (\n        user_id,\n        title,\n        message,\n        type,\n        related_battle_id,\n        is_read,\n        created_at,\n        updated_at\n      ) VALUES (\n        v_battle_rec.player1_user_id,\n        'ãƒãƒˆãƒ«çµæœ',\n        FORMAT('å¯¾æˆ¦ç›¸æ‰‹ %s ã•ã‚“ã¨ã®ãƒãƒˆãƒ«ã¯æƒœæ•—ã§ã—ãŸã€‚æ¬¡å›é ‘å¼µã‚Šã¾ã—ã‚‡ã†ï¼', COALESCE(v_player2_username, 'Unknown')),\n        'battle_lose',\n        p_battle_id,\n        false,\n        NOW(),\n        NOW()\n      );\n    ELSE\n      -- å¼•ãåˆ†ã‘é€šçŸ¥\n      INSERT INTO public.notifications (\n        user_id,\n        title,\n        message,\n        type,\n        related_battle_id,\n        is_read,\n        created_at,\n        updated_at\n      ) VALUES (\n        v_battle_rec.player1_user_id,\n        'ãƒãƒˆãƒ«çµæœ',\n        FORMAT('å¯¾æˆ¦ç›¸æ‰‹ %s ã•ã‚“ã¨ã®ãƒãƒˆãƒ«ã¯å¼•ãåˆ†ã‘ã§ã—ãŸã€‚', COALESCE(v_player2_username, 'Unknown')),\n        'battle_draw',\n        p_battle_id,\n        false,\n        NOW(),\n        NOW()\n      );\n    END IF;\n  END IF;\n\n  -- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2ã¸ã®é€šçŸ¥\n  IF NOT v_player2_deleted THEN\n    IF p_winner_id = v_battle_rec.player2_user_id THEN\n      -- å‹åˆ©é€šçŸ¥\n      INSERT INTO public.notifications (\n        user_id,\n        title,\n        message,\n        type,\n        related_battle_id,\n        is_read,\n        created_at,\n        updated_at\n      ) VALUES (\n        v_battle_rec.player2_user_id,\n        'ãƒãƒˆãƒ«å‹åˆ©ï¼',\n        FORMAT('å¯¾æˆ¦ç›¸æ‰‹ %s ã•ã‚“ã¨ã®ãƒãƒˆãƒ«ã«å‹åˆ©ã—ã¾ã—ãŸï¼', COALESCE(v_player1_username, 'Unknown')),\n        'battle_win',\n        p_battle_id,\n        false,\n        NOW(),\n        NOW()\n      );\n    ELSIF p_winner_id = v_battle_rec.player1_user_id THEN\n      -- æ•—åŒ—é€šçŸ¥\n      INSERT INTO public.notifications (\n        user_id,\n        title,\n        message,\n        type,\n        related_battle_id,\n        is_read,\n        created_at,\n        updated_at\n      ) VALUES (\n        v_battle_rec.player2_user_id,\n        'ãƒãƒˆãƒ«çµæœ',\n        FORMAT('å¯¾æˆ¦ç›¸æ‰‹ %s ã•ã‚“ã¨ã®ãƒãƒˆãƒ«ã¯æƒœæ•—ã§ã—ãŸã€‚æ¬¡å›é ‘å¼µã‚Šã¾ã—ã‚‡ã†ï¼', COALESCE(v_player1_username, 'Unknown')),\n        'battle_lose',\n        p_battle_id,\n        false,\n        NOW(),\n        NOW()\n      );\n    ELSE\n      -- å¼•ãåˆ†ã‘é€šçŸ¥\n      INSERT INTO public.notifications (\n        user_id,\n        title,\n        message,\n        type,\n        related_battle_id,\n        is_read,\n        created_at,\n        updated_at\n      ) VALUES (\n        v_battle_rec.player2_user_id,\n        'ãƒãƒˆãƒ«çµæœ',\n        FORMAT('å¯¾æˆ¦ç›¸æ‰‹ %s ã•ã‚“ã¨ã®ãƒãƒˆãƒ«ã¯å¼•ãåˆ†ã‘ã§ã—ãŸã€‚', COALESCE(v_player1_username, 'Unknown')),\n        'battle_draw',\n        p_battle_id,\n        false,\n        NOW(),\n        NOW()\n      );\n    END IF;\n  END IF;\n\n  -- 11. active_battlesã¨battle_votesã‹ã‚‰å‰Šé™¤ï¼ˆCASCADEï¼‰\n  DELETE FROM public.active_battles WHERE id = p_battle_id;\n\n  -- 12. æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’è¿”ã™\n  RETURN json_build_object(\n    'success', true,\n    'archived_battle_id', v_archived_battle_id,\n    'winner_id', p_winner_id,\n    'final_votes_a', v_battle_rec.votes_a,\n    'final_votes_b', v_battle_rec.votes_b,\n    'player1_video_url', v_player1_video_url,\n    'player2_video_url', v_player2_video_url,\n    'player1_deleted', v_player1_deleted,\n    'player2_deleted', v_player2_deleted,\n    'rating_update', v_rating_result,\n    'season_points_update', v_season_result,\n    'notifications_sent', CASE \n      WHEN v_player1_deleted AND v_player2_deleted THEN 0\n      WHEN v_player1_deleted OR v_player2_deleted THEN 1\n      ELSE 2\n    END\n  );\n\nEXCEPTION\n  WHEN OTHERS THEN\n    RETURN json_build_object(\n      'success', false,\n      'error', 'Transaction failed',\n      'error_details', SQLERRM\n    );\nEND;\n$function$\n"
  }
]
